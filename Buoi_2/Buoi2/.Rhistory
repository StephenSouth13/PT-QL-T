library(readxl)
library(dplyr)
df<-read_excel("D:/UEH/PT-QL-T/Buoi_2/stock_prices.excel",sheet ="Prices")
library(readxl)
library(dplyr)
# Thử với .xlsx
df <- read_excel("D:/UEH/PT-QL-T/Buoi_2/stock_prices.xlsx", sheet = "Prices")
# Hoặc thử với .xls (nếu là file đời cũ)
df <- read_excel("D:/UEH/PT-QL-T/Buoi_2/stock_prices.xls", sheet = "Prices")
df <- df %>%
mutate(Date = as.Date(Date)) %>%
arrange(Date)
library(readxl)
library(dplyr)
# Thử với .xlsx
df <- read_excel("D:/UEH/PT-QL-T/Buoi_2/stock_prices.xlsx", sheet = "Prices")
# 2) Đảm bảo Date là Date và sắp theo thời gian
df <- df %>%
mutate(Date = as.Date(Date)) %>%
arrange(Date)
# 3) Tính return từ Close
df <- df %>%
mutate(
ret_close = Close / lag(Close) - 1,          # simple return
logret_close = log(Close / lag(Close))       # log return
)
# 4) Xem kết quả
head(df, 10)
summary(df$ret_close)
rm(list = ls())
data("EuStockMarkets")
P <-EuStockMarkets
head(P)
R <-diff(log(P))
R <-as.matrix(R)
head(R)
# Simple return (nếu muốn)R_simple <-P[-1,]/P[-nrow(P),] -1R_simple <-as.matrix(R_simple)
R_simple <-P[-1,]/P[-nrow(P),] -1
R_simple <-as.matrix(R_simple)
mu  <-colMeans(R)
sdv <-apply(R, 2, sd)
varv <-apply(R, 2, var)
summary_stats <-cbind(mean = mu, sd = sdv, var = varv,min = apply(R,2,min),q05 = apply(R,2,quantile, probs=0.05),median = apply(R,2,median),q95 = apply(R,2,quantile, probs=0.95),max = apply(R,2,max))round(summary_stats, 6)
summary_stats <-cbind(mean = mu, sd = sdv, var = varv,min = apply(R,2,min),q05 = apply(R,2,quantile, probs=0.05),median = apply(R,2,median),q95 = apply(R,2,quantile, probs=0.95),max = apply(R,2,max))
round(summary_stats, 6)
skew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})
skew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})
skew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})ex_kurt <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^4) / (s^4) -3})
skew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})ex_kurt <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^4) / (s^4) -3})
# Skewness và excess kurtosis: công thức momentskew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})ex_kurt <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^4) / (s^4) -3})
skew
skew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})
summary_stats <-cbind(mean = mu, sd = sdv, var = varv,min = apply(R,2,min),q05 = apply(R,2,quantile, probs=0.05),median = apply(R,2,median),q95 = apply(R,2,quantile, probs=0.95),max = apply(R,2,max))
round(summary_stats, 6)
# Skewness và excess kurtosis: công thức momentskew <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^3) / (s^3)})ex_kurt <-apply(R, 2, function(x){m <-mean(x); s <-sd(x)mean((x -m)^4) / (s^4) -3})
skew
# Tính Skewness
skew <- apply(R, 2, function(x) {
m <- mean(x)
s <- sd(x)
mean((x - m)^3) / (s^3)
})
# Gọi kết quả để xem
skew
# Tính Excess Kurtosis
ex_kurt <- apply(R, 2, function(x) {
m <- mean(x)
s <- sd(x)
mean((x - m)^4) / (s^4) - 3
})
# Gọi kết quả để xem
ex_kurt
install.packages("PerformanceAnalytics")
round(cbind(skew = skew, ex_kurt = ex_kurt), 4)
# n là số quan sát
n <- nrow(R)
# Tính giá trị thống kê JB
JB <- (n/6) * (skew^2 + (ex_kurt^2)/4)
# Tính p-value từ phân phối Chi-bình phương với 2 bậc tự do
pval <- 1 - pchisq(JB, df = 2)
# Tổng hợp kết quả và làm tròn 6 chữ số thập phân
results_JB <- round(cbind(JB = JB, p_value = pval), 6)
print(results_JB)
# Lấy dữ liệu của chỉ số DAX
x <- R[, "DAX"]
# Vẽ biểu đồ Histogram
hist(x, breaks = 50, col = "skyblue",
main = "DAX log-returns Distribution",
xlab = "Log return", prob = TRUE)
lines(density(x), col = "red", lwd = 2) # Thêm đường mật độ thực tế
# Vẽ biểu đồ Q-Q Plot
qqnorm(x, main = "Normal Q-Q Plot for DAX")
qqline(x, col = "red", lwd = 2)
# 1. Trích xuất dữ liệu của FTSE
x_ftse <- R[, "FTSE"]
# 2. Vẽ biểu đồ Histogram
hist(x_ftse,
breaks = 50,
col = "lightgreen",
main = "FTSE log-returns",
xlab = "log returns",     # Đặt tên nhãn trục hoành theo yêu cầu
prob = TRUE)              # Vẽ theo mật độ để chèn được đường density
# 3. Thêm đường mật độ thực tế của dữ liệu
lines(density(x_ftse), col = "red", lwd = 2)
# 4. Vẽ đồ thị Q-Q Plot để kiểm tra trực quan
qqnorm(x_ftse, main = "Normal Q-Q Plot for FTSE")
qqline(x_ftse, col = "blue", lwd = 2)
# Vẽ lại histogram với màu sắc và đường mật độ
hist(x, breaks = 50, main = "FTSE log-returns",
xlab = "log return", col = "steelblue", border = "white", prob = TRUE)
# Thêm đường mật độ thực tế (màu đỏ)
lines(density(x), col = "red", lwd = 2)
